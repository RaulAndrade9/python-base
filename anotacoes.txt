--------------------GERAL--------------------
criar um ambiente virtual para o python
python -m venv .venv

habilitar o powershell para executar script:
Set-ExecutionPolicy Unrestricted

pyformat(pra ver as especificações de formatação)

dir(nome do objeto) -> mostra os métodos e protocolos do objeto.
tem que ser executado dentro de um terminal python

pep8.org - estilos python

--------------------FORMATAÇÃO--------------------
variavel.srtip("caractere") - remove todos os caracteres da variável
ex: nome = "Raul-Santos-Andrade"
    nome.strip("-")
    print(nome)
    RaulSantosAndrade

variavel.lstript() - remove o caracter definido nos parênteses apenas a esquerda

formatando usando o %

mensagem  = "Olá, %s, voce é o participante número %d e pode ganhar %.2f pontos."
- colocar ao lado do % o tipo de dado (s=string, d=double, f=float)
posso exibir através do print(mensagem % ("Raul", 8, 150)) ou se tiver sido atribuido a uma variável ex:
nome = Raul
numero = 8
pontos = 150
print(mensagem % (nome, numero, pontos))


Usanto o format 

mensagem  = "Olá, {}, voce é o participante número {} e pode ganhar {:.2f} pontos."

print(mensagem.format("Raul", 8, 150))
ou
print(mensagem.format(nome, numero, pontos))


Usando F string
nome = "Raul"

print(f"{nome:-^40}")
***Lembrar de colocar as chaves entre as ""

--------------------CONJUNTOS--------------------
conjunto_a = set([1, 2, 3,4 ,5 ,6])
conjunto_b = set([4, 5, 6, 7,8 ,9])

set não são iteráveis

novo_set = set (conjunto_a).union (set(conjunto_b)) mostra a união do dois conjuntos ou conjunto_a | conjunto_b

novo_set = conjunto_a.intersection(conjunto_b) ou conjunto_a & conjunto_b mostra a intersecção entre os conjuntos

novo_set = conjunto_a - conjunto_b ou conjunto_a.difference(conjunto_b) mostra a diferença entre os conjuntos, a ordem importa MUITO

novo_set = conjunto_a.symmetric_difference(conjunto_b) ou conjunto_a ^ conjunto_b
mostra a diferença simétrica entre os conjuntos (todos os elementos, exceto os que há em comum entre os dois conjuntos)

--------------------DICIONARIO--------------------
Quando cria um dicionário, há as informações de Key e Value (separados por um :)
Para separar um elemento de outro usa uma vírgula
criar:
cliente = {"nome": "Raul", "endereco": "Servidei Demarchi", "cidade":"São Bernardo do Campo"}

cliente.key() - mostra as keys do dicionário
cliente.values() - mostra os values do dicionário
cliente.items() - mostra as keys e os values


cliente.update(outro_dicionario) - adciona as informações de outro dicionário ao cliente

final = (**cliente, **outro_dicionario) - desempacota os dois dicionários dentro de um dicionário novo chamado 'final'

iterar no dicionário
for chave in cliente:
    print(chave, cliente[chave])


por padrão a iteração só traz a chave, mas é possível trazer também o valor com key[value]


--------------------CRIAR ARQUIVOS COM IPYTHON UTILIZANDO MÓDULO OS--------------------
import.os -> importa o módulo necessário

os.mkdir("nome_da_pasta") -> cria uma pasta

os.listdir(os.curdir) -> lista os arquivos no diretório atual

os.makedirs("nome_da_pasta/subpasta", exist_ok=True) cria uma pasta dentro da pasta já criada*

path = os.path.join("pasta", "subpasta") -> cria um path para onde provavelmente o arquivo manipulado estará

file_path = os.path.join(path, "arquivo.txt") -> armazena o arquivo em uma variável, facilitando pra quando for necessário abrir, ler

arquivo = open('arquivo.txt', 'w') -> abre o arquivo no modo de escrita

arquivo = open('arquivo.txt', 'r') -> abre o arquivo no modo de leitura

arquivo = open('arquivo.txt', 'a') -> abre o arquivo no modo append, que é quando queremos adcionar informações sem apagar as que já estavam lá.
O modo 'w' apaga o que ja tem e insere novas informações

arquivo.close() -> fecha o arquivo
  

após usar o read pra ler o arquivo, não é possível ler de novo, pois ele consome o arquivo, como se fosse um buffer
Utilizar o open cria um arquivo mesmo que ele não exista.

Utilizando o context manager, é possível abrir e manipular o arquivo sem precisar utilizar o .close, pois ele fecha o arquivo sozinho.
Ex:
with open('arquivo.txt', 'a') as arquivo:
    arquivo.write("Hello World")
    arquivo.write("teste)

Ao quebrar a identação o arquivo será fechado.
**OBS: lembrar de usar \n para quebrar a linha

é possível escrever em um arquivo utilizando o print. Ex:
print("Brasil", file=open('arquivo.txt', 'a'))
O print já insere o \n e também ja fecha o arquivo.

**usar o print para abrir e ler o arquivo**
print(open('arquivo.txt').read())

É possível inserir diversas linhas em um arquivo utilzando o método writelines, inserindo as linhas em uma lista e depois inserindo essa lista.
lista = [lista com diversas linhas]
with open('texto.txt', 'a') as arquivo:
    arquivo.writelines(lista)

utilizando o .readlines, é possível ler linha a linha ao invés do texto todo como no read. O readlines devolve uma lista. Ex:
open('texto.txt').readlines()
['titulo\n', '\n', 'Este post fala sobre\n', 'O assunto é sobre\n']


--------------------CRIAR ARQUIVOS COM IPYTHON UTILIZANDO MÓDULO PATH--------------------
from pathlib import Path - para importar o módulo


Path("pasta)
WindowsPath('pasta')

para substituir o que fiz anteriormente e passar o caminho da pasta, utilizaremos:
path = Path("pasta") / Path("subpasta")

dessa forma podemos utilizar
filepath = path / Path("novo.txt") - para descrever um caminho para o arquivo novo.txt

filepath.write_text("texto")-> para escrever no arquivo

filepath.read_text() -> pra ler o arquivo